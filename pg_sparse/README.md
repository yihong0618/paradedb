<h1 align="center">
  <img src="../docs/logo/pg_sparse.svg" alt="pg_sparse" width="500px"></a>
<br>
</h1>

# Overview

`pg_sparse` is `pgvector` for sparse vectors. It enables the storage and retrieval of sparse
vectors within Postgres.

Generated by sparse embedding models like SPLADE, sparse vectors are different from dense vectors because they contain significantly more entries, most of which are zero. Storing raw sparse vectors in Postgres and calculating distances between them incurs extremely high storage and performance costs. `pg_sparse`` solves this by compressing the sparse vectors and constructing an HNSW graph over the compressed vector representations.

`pg_sparse` is a fork of `pgvector` and is supported on all versions supported by the PostgreSQL Global Development Group, which includes PostgreSQL 12+.

## Installation

### From Self-Hosted PostgreSQL

Compile and install the extension (supports Postgres 11+)

```sh
cd /tmp
git clone --branch v0.5.1 https://github.com/paradedb/paradedb.git
cd paradedb/pg_sparse
make
make install # may need sudo
```

### From ParadeDB

`pg_sparse` is in beta. As a result, it has not yet been added to ParadeDB.

## Getting Started

Enable the extension (do this once in each database where you want to use it)

```tsql
CREATE EXTENSION svector;
```

Create a svector column with 3 dimensions

```sql
CREATE TABLE items (id bigserial PRIMARY KEY, embedding svector(3));
```

Insert vectors

```sql
INSERT INTO items (embedding) VALUES ('[1,2,3]'), ('[4,5,6]');
```

Get the nearest neighbors by L2 distance

```sql
SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;
```

Also supports inner product (`<#>`) and cosine distance (`<=>`)

Note: `<#>` returns the negative inner product since Postgres only supports `ASC` order index scans on operators

## Storing

Create a new table with a svector column

```sql
CREATE TABLE items (id bigserial PRIMARY KEY, embedding svector(3));
```

Or add a svector column to an existing table

```sql
ALTER TABLE items ADD COLUMN embedding svector(3);
```

Insert vectors

```sql
INSERT INTO items (embedding) VALUES ('[1,2,3]'), ('[4,5,6]');
```

Upsert vectors

```sql
INSERT INTO items (id, embedding) VALUES (1, '[1,2,3]'), (2, '[4,5,6]')
    ON CONFLICT (id) DO UPDATE SET embedding = EXCLUDED.embedding;
```

Update vectors

```sql
UPDATE items SET embedding = '[1,2,3]' WHERE id = 1;
```

Delete vectors

```sql
DELETE FROM items WHERE id = 1;
```

## Querying

Get the nearest neighbors to a svector

```sql
SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;
```

Get the nearest neighbors to a row

```sql
SELECT * FROM items WHERE id != 1 ORDER BY embedding <-> (SELECT embedding FROM items WHERE id = 1) LIMIT 5;
```

Get rows within a certain distance

```sql
SELECT * FROM items WHERE embedding <-> '[3,1,2]' < 5;
```

Note: Combine with `ORDER BY` and `LIMIT` to use an index

### Distances

Get the distance

```sql
SELECT embedding <-> '[3,1,2]' AS distance FROM items;
```

For inner product, multiply by -1 (since `<#>` returns the negative inner product)

```tsql
SELECT (embedding <#> '[3,1,2]') * -1 AS inner_product FROM items;
```

For cosine similarity, use 1 - cosine distance

```sql
SELECT 1 - (embedding <=> '[3,1,2]') AS cosine_similarity FROM items;
```

## HNSW Index

By default, pgvector performs exact nearest neighbor search, which provides perfect recall.

You can add an HNSW index to use approximate nearest neighbor search, which trades some recall for speed. Unlike typical indexes, you will see different results for queries after adding an approximate index.

Add an index for each distance function you want to use.

L2 distance

```sql
CREATE INDEX ON items USING shnsw (embedding svectorl2_ops);
```

Inner product

```sql
CREATE INDEX ON items USING shnsw (embedding svectorip_ops);
```

Cosine distance

```sql
CREATE INDEX ON items USING shnsw (embedding svector_cosine_ops);
```

Vectors with up to 2,000 dimensions can be indexed.

### Index Options

Specify HNSW parameters

- `m` - the max number of connections per layer (16 by default)
- `ef_construction` - the size of the dynamic candidate list for constructing the graph (64 by default)

```sql
CREATE INDEX ON items USING shnsw (embedding svectorl2_ops) WITH (m = 16, ef_construction = 64);
```

### Query Options

Specify the size of the dynamic candidate list for search (40 by default)

```sql
SET shnsw.ef_search = 100;
```

A higher value provides better recall at the cost of speed.

Use `SET LOCAL` inside a transaction to set it for a single query

```sql
BEGIN;
SET LOCAL shnsw.ef_search = 100;
SELECT ...
COMMIT;
```

### Indexing Progress

Check [indexing progress](https://www.postgresql.org/docs/current/progress-reporting.html#CREATE-INDEX-PROGRESS-REPORTING) with Postgres 12+

```sql
SELECT phase, round(100.0 * blocks_done / nullif(blocks_total, 0), 1) AS "%" FROM pg_stat_progress_create_index;
```

The phases for HNSW are:

1. `initializing`
2. `loading tuples`

## Filtering

There are a few ways to index nearest neighbor queries with a `WHERE` clause

```sql
SELECT * FROM items WHERE category_id = 123 ORDER BY embedding <-> '[3,1,2]' LIMIT 5;
```

Create an index on one [or more](https://www.postgresql.org/docs/current/indexes-multicolumn.html) of the `WHERE` columns for exact search

```sql
CREATE INDEX ON items (category_id);
```

Or a [partial index](https://www.postgresql.org/docs/current/indexes-partial.html) on the svector column for approximate search

```sql
CREATE INDEX ON items USING ivfflat (embedding svectorl2_ops) WITH (lists = 100)
    WHERE (category_id = 123);
```

Use [partitioning](https://www.postgresql.org/docs/current/ddl-partitioning.html) for approximate search on many different values of the `WHERE` columns

```sql
CREATE TABLE items (embedding svector(3), category_id int) PARTITION BY LIST(category_id);
```

## Performance

Use `EXPLAIN ANALYZE` to debug performance.

```sql
EXPLAIN ANALYZE SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;
```
